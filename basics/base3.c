#include <stdio.h>

// 数组
// C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

// 数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

// 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

double balance[10];

void func1()
{
    int n[10]; /* n 是一个包含 10 个整数的数组 */
    int i, j;
    
    for(int i = 0; i < 10; i++)
    {
        /* code */
        n[i] = i + 100; /* 设置元素 i 为 i + 100 */
    }
    /* 输出数组中每个元素的值 */
    for (j = 0; j < 10; j++ )
    {
        printf("Element[%d] = %d\n", j, n[j] );
    }
}


// 指针
// 学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。
// 所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。
// 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

// 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。
// 就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。
// 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。
// 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

void func2()
{
    int  var1;
    char var2[10];
    printf("var1 变量的地址： %p\n", &var1);
    printf("var2 变量的地址： %p\n", &var2);

    int  var = 20;   /* 实际变量的声明 */
    int  *ip;        /* 指针变量的声明 */
    
    ip = &var;  /* 在指针变量中存储 var 的地址 */
    
    printf("Address of var variable: %p\n", &var);
    
    /* 在指针变量中存储的地址 */
    printf("Address stored in ip variable: %p\n", ip);
    
    /* 使用指针访问值 */
    printf("Value of *ip variable: %d\n", *ip);
    *ip = 30;
    printf("Value of *ip variable: %d\n", *ip);
}

// 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。

void func3()
{
    int  *ptr = NULL;
    printf("ptr 的地址是 %p\n", ptr);
}

// 指针的算术运算
// C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。

const int Max = 3;

void func4()
{
    int  var[] = {10, 100, 200};
    int  i, *ptr;
    ptr = var;

    for(int i = 0; i < Max; i++)
    {
        /* code */
        printf("存储地址：var[%d] = %p\n", i, ptr);
        printf("存储值：var[%d] = %d\n", i, *ptr);
        /* 移动到下一个位置 */
        ptr++;
    }

    // 递减一个指针
    /* 指针中最后一个元素的地址 */
    ptr = &var[Max-1];
    for ( i = Max; i > 0; i--)
    {

        printf("存储地址：var[%d] = %p\n", i-1, ptr);
        printf("存储值：var[%d] = %d\n", i-1, *ptr);

        /* 移动到下一个位置 */
        ptr--;
    }
}


/*

int 变量存的是 int 型的值，char 变量存的是 char 型的值，
而指针，它是一种特殊的变量，存的是内存地址，按照这个模板可以把它理解为：“内存地址变量” 存的是 “内存地址”，等价于：“指针变量” 存的是 “内存地址”

操作系统进行资源调度时，会根据这些变量存的地址去请求和使用那个地址代表的内存区域，
这就仿佛像是这个变量存的地址指向了某片内存，人们用 “指针” 来统称所谓的 “内存地址变量”

因此，任何跟指针有关的概念，都可以联系内存地址加以理解，二者必然有联系，数组与指针，函数与指针，都是如此。

 内存是线性的，内存以地址空间的形式呈现给我们看的，所以可以说所谓的地址空间也是线性的，指针存放的是内存地址，所以你可以对地址做 ++，或者 -- 这样的运算。
 两个指针不赋 NULL，是坏习惯
 初始化指针不赋 NULL，因为这样的指针会指向一片未知的区域，这样的指针不是空指针，但指向一片访问受限制的内存区域，你无法使用它，这样的情况下的指针，业界给了它一个形象的名字：“野指针”，而且难以调试，在许多编译器单步 debug 会出现奇怪的错误，但经常看见的 "Segmentation Fault" 这样的错误，实测当代码多的时候，这是一个非常蛋疼的错误，野指针就是成因之一，所以看到这样的错误，首先是想想，是否有某些指针没有初始化引起的
 free() 后指针不赋 NULL，为指针分配内存后，指针便可以指向一片合法可使用的内存，但使用 free() 释放那片内存时，指针依旧存放着那片内存的地址，也就是依旧指向那片内存，但这片内存已经释放，不可访问，这时若不小心使用了这个指针，便会内存错误，又是会有奇怪的 bug ，代码几百行多点就会难以调试，业界给这样的指针也有个统称：“悬空指针”，为了避免这种蛋疼的情况出现，一定要释放内存后，给指向这片内存的指针，都赋值为 NULL，从中也可以看出，free() 这个函数释放内存时跟指向这片内存的指针并没有什么卵关系，不会连着把指针一起搞定掉的！ 珍爱生命，远离 "野指针" 与 "悬空指针" ！
 多级指针，指向指针的指针，有时人们也管它叫多维指针。既然指针变量是一个变量，指针变量能存变量的内存的地址。
像 int * 存 int 型变量的地址，char * 存 char 型的地址，那指针理所当然可以存指针变量的地址啊。

例如，int ** 存 int * 的地址，int *** 存 int ** 的地址。

这就是一个二级指针存一级指针的地址，三级指针存二级指针的地址，人们把这样的过程叫指向指针的指针，但其实也就是一个上一级的指针存了下一级的指针的地址而已。

因此，像上面说的，你存了它的地址，你就是指向它，所以：

 二级指针存一级指针的地址，那么可以说二级指针指向一级指针
 三级指针存二级指针的地址，那么可以说二级指针指向一级指针
 多级指针用处多多， 这里暂不举例详细说明。
个人认为指针可以说是 C 的最伟大的特性，通过这样的一个模型可以形象地管理部分内存！

*/

int main(int argc, char const *argv[])
{
    /* code */
    // func1();
    func2();
    func3();
    func4();
    return 0;
}
